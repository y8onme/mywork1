# src/core/analyzers/vulnerability_amplifier.py

import asyncio
from typing import Dict, List, Optional, Set
from dataclasses import dataclass
from ...utils.config import config
from ...utils.logger import logger
from ...utils.state.state_manager import StateManager
from ..vulnerability_scanner import VulnerabilityScanner

@dataclass
class AmplificationVector:
    vulnerability_id: str
    chain_id: int
    protocol_address: str
    amplification_type: str
    amplification_factor: float
    required_conditions: List[Dict]
    estimated_impact: Dict
    execution_steps: List[Dict]
    risk_level: float
    confidence_score: float

@dataclass
class AmplificationAnalysis:
    original_vulnerability: Dict
    amplification_vectors: List[AmplificationVector]
    combined_risk_score: float
    max_impact: Dict
    chain_id: int
    timestamp: float

class VulnerabilityAmplifier:
    def __init__(self):
        self.state_manager = StateManager()
        self.vulnerability_scanner = VulnerabilityScanner()
        self.analyzed_vulnerabilities: Set[str] = set()
        self.amplification_history: Dict[str, List[AmplificationAnalysis]] = {}
        
    async def analyze_amplification(self,
                                  vulnerability: Dict,
                                  chain_id: int,
                                  options: Optional[Dict] = None) -> Optional[AmplificationAnalysis]:
        """Analyze potential vulnerability amplification vectors"""
        try:
            start_time = asyncio.get_event_loop().time()
            options = options or {}
            
            # Get protocol state
            state = await self.state_manager.get_state(chain_id)
            
            # Find amplification vectors
            vectors = await self._find_amplification_vectors(
                vulnerability,
                chain_id,
                state
            )
            
            if not vectors:
                return None
                
            # Calculate combined risk
            combined_risk = self._calculate_combined_risk(
                vulnerability,
                vectors
            )
            
            # Calculate maximum impact
            max_impact = self._calculate_max_impact(
                vulnerability,
                vectors
            )
            
            analysis = AmplificationAnalysis(
                original_vulnerability=vulnerability,
                amplification_vectors=vectors,
                combined_risk_score=combined_risk,
                max_impact=max_impact,
                chain_id=chain_id,
                timestamp=start_time
            )
            
            # Update history
            self._update_amplification_history(analysis)
            
            return analysis
            
        except Exception as e:
            logger.error(f"Error analyzing amplification: {str(e)}")
            return None

    async def _find_amplification_vectors(self,
                                        vulnerability: Dict,
                                        chain_id: int,
                                        state: Dict) -> List[AmplificationVector]:
        """Find potential amplification vectors"""
        try:
            vectors = []
            
            # Check flash loan amplification
            flash_loan_vector = await self._check_flash_loan_amplification(
                vulnerability,
                chain_id,
                state
            )
            if flash_loan_vector:
                vectors.append(flash_loan_vector)
                
            # Check cross-protocol amplification
            cross_protocol_vectors = await self._check_cross_protocol_amplification(
                vulnerability,
                chain_id,
                state
            )
            vectors.extend(cross_protocol_vectors)
            
            # Check market manipulation amplification
            market_vector = await self._check_market_manipulation_amplification(
                vulnerability,
                chain_id,
                state
            )
            if market_vector:
                vectors.append(market_vector)
                
            # Check governance amplification
            governance_vector = await self._check_governance_amplification(
                vulnerability,
                chain_id,
                state
            )
            if governance_vector:
                vectors.append(governance_vector)
                
            return vectors
            
        except Exception as e:
            logger.error(f"Error finding amplification vectors: {str(e)}")
            return []

    async def _check_flash_loan_amplification(self,
                                            vulnerability: Dict,
                                            chain_id: int,
                                            state: Dict) -> Optional[AmplificationVector]:
        """Check for flash loan amplification potential"""
        try:
            # Get flash loan providers
            providers = await self._get_flash_loan_providers(chain_id)
            
            # Calculate potential amplification
            max_amplification = 0
            best_provider = None
            
            for provider in providers:
                amplification = await self._calculate_flash_loan_amplification(
                    vulnerability,
                    provider,
                    chain_id
                )
                
                if amplification > max_amplification:
                    max_amplification = amplification
                    best_provider = provider
                    
            if max_amplification <= 1:
                return None
                
            # Generate execution steps
            steps = await self._generate_flash_loan_steps(
                vulnerability,
                best_provider,
                chain_id
            )
            
            return AmplificationVector(
                vulnerability_id=vulnerability['id'],
                chain_id=chain_id,
                protocol_address=vulnerability['protocol_address'],
                amplification_type='flash_loan',
                amplification_factor=max_amplification,
                required_conditions=self._get_flash_loan_conditions(best_provider),
                estimated_impact=self._calculate_flash_loan_impact(
                    vulnerability,
                    max_amplification
                ),
                execution_steps=steps,
                risk_level=self._calculate_flash_loan_risk(max_amplification),
                confidence_score=self._calculate_flash_loan_confidence(steps)
            )
            
        except Exception as e:
            logger.error(f"Error checking flash loan amplification: {str(e)}")
            return None

    async def _check_cross_protocol_amplification(self,
                                                vulnerability: Dict,
                                                chain_id: int,
                                                state: Dict) -> List[AmplificationVector]:
        """Check for cross-protocol amplification potential"""
        try:
            vectors = []
            
            # Get related protocols
            related_protocols = await self._get_related_protocols(
                vulnerability['protocol_address'],
                chain_id
            )
            
            for protocol in related_protocols:
                # Check for interaction potential
                interaction = await self._check_protocol_interaction(
                    vulnerability,
                    protocol,
                    chain_id
                )
                
                if not interaction['has_potential']:
                    continue
                    
                # Calculate amplification
                amplification = await self._calculate_cross_protocol_amplification(
                    vulnerability,
                    protocol,
                    interaction,
                    chain_id
                )
                
                if amplification > 1:
                    vectors.append(AmplificationVector(
                        vulnerability_id=vulnerability['id'],
                        chain_id=chain_id,
                        protocol_address=vulnerability['protocol_address'],
                        amplification_type='cross_protocol',
                        amplification_factor=amplification,
                        required_conditions=interaction['conditions'],
                        estimated_impact=self._calculate_cross_protocol_impact(
                            vulnerability,
                            protocol,
                            amplification
                        ),
                        execution_steps=interaction['steps'],
                        risk_level=self._calculate_cross_protocol_risk(
                            vulnerability,
                            protocol,
                            amplification
                        ),
                        confidence_score=interaction['confidence']
                    ))
                    
            return vectors
            
        except Exception as e:
            logger.error(f"Error checking cross-protocol amplification: {str(e)}")
            return []

    def _calculate_combined_risk(self,
                               vulnerability: Dict,
                               vectors: List[AmplificationVector]) -> float:
        """Calculate combined risk score"""
        try:
            base_risk = vulnerability.get('risk_score', 0.5)
            
            # Calculate amplified risk
            amplified_risk = max(
                vector.risk_level * vector.amplification_factor
                for vector in vectors
            )
            
            # Combine risks
            combined_risk = base_risk * (1 + amplified_risk)
            
            return min(combined_risk, 1.0)
            
        except Exception as e:
            logger.error(f"Error calculating combined risk: {str(e)}")
            return 1.0

    def _calculate_max_impact(self,
                            vulnerability: Dict,
                            vectors: List[AmplificationVector]) -> Dict:
        """Calculate maximum potential impact"""
        try:
            base_impact = vulnerability.get('impact', {})
            max_impact = base_impact.copy()
            
            for vector in vectors:
                impact = vector.estimated_impact
                
                # Update financial impact
                max_impact['financial'] = max(
                    max_impact.get('financial', 0),
                    impact.get('financial', 0)
                )
                
                # Update user impact
                max_impact['users_affected'] = max(
                    max_impact.get('users_affected', 0),
                    impact.get('users_affected', 0)
                )
                
                # Update protocol impact
                max_impact['protocol_damage'] = max(
                    max_impact.get('protocol_damage', 0),
                    impact.get('protocol_damage', 0)
                )
                
            return max_impact
            
        except Exception as e:
            logger.error(f"Error calculating max impact: {str(e)}")
            return {}

    def _update_amplification_history(self, analysis: AmplificationAnalysis):
        """Update amplification history"""
        try:
            vuln_id = analysis.original_vulnerability['id']
            
            if vuln_id not in self.amplification_history:
                self.amplification_history[vuln_id] = []
                
            self.amplification_history[vuln_id].append(analysis)
            
            # Limit history size
            if len(self.amplification_history[vuln_id]) > 10:
                self.amplification_history[vuln_id] = \
                    self.amplification_history[vuln_id][-10:]
                
        except Exception as e:
            logger.error(f"Error updating amplification history: {str(e)}")
