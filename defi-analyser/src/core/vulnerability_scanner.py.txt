# Enhancing vulnerability scanner with new detection capabilities... 

import asyncio
from typing import Dict, List, Optional, Set
from dataclasses import dataclass
from ..utils.config import config
from ..utils.logger import logger
from ..utils.state.state_manager import StateManager
from ..utils.llm_interface import LLMInterface
import tempfile
from slither import Slither
from mythril.mythril import MythrilDisassembler, MythrilAnalyzer
from manticore.ethereum import ManticoreEVM
from echidna import Echidna
from crytic_compile import CryticCompile
import logging

@dataclass
class Vulnerability:
    id: str
    name: str
    type: str
    severity: float  # 0-1 scale
    confidence: float
    description: str
    impact: Dict
    attack_vectors: List[Dict]
    affected_functions: List[str]
    proof_of_concept: Optional[str]
    exploit_script: Optional[str]
    mitigation: str
    references: List[str]
    dependencies: List[str]
    chain_id: int
    detection_tool: str

class SmartContractAnalyzer:
    """Integrates multiple open source analysis tools"""
    
    def __init__(self, web3_client):
        self.web3 = web3_client
        self.mythril = MythrilAnalyzer()
        self.manticore = ManticoreEVM()
        
    async def analyze_contract(self, contract_address: str, source_code: Optional[str] = None) -> Dict:
        """Analyze contract using multiple tools"""
        try:
            results = {
                'vulnerabilities': [],
                'warnings': [],
                'decompiled': None,
                'storage_layout': None,
                'analysis': {}
            }

            # 1. Slither Analysis (if source code available)
            if source_code:
                slither_results = await self._run_slither_analysis(source_code)
                results['analysis']['slither'] = slither_results

            # 2. Mythril Analysis (works on bytecode)
            mythril_results = await self._run_mythril_analysis(contract_address)
            results['analysis']['mythril'] = mythril_results

            # 3. Manticore Analysis (symbolic execution)
            manticore_results = await self._run_manticore_analysis(contract_address)
            results['analysis']['manticore'] = manticore_results

            # 4. Echidna (if source code available)
            if source_code:
                echidna_results = await self._run_echidna_tests(source_code)
                results['analysis']['echidna'] = echidna_results

            # 5. Use Panoramix/Etherscan for decompilation
            decompiled = await self._decompile_contract(contract_address)
            results['decompiled'] = decompiled

            return results

        except Exception as e:
            logger.error(f"Error in contract analysis: {str(e)}")
            return {'error': str(e)}

    async def _run_slither_analysis(self, source_code: str) -> Dict:
        """Run Slither static analyzer
        
        Slither is excellent for:
        - Vulnerability detection
        - Contract inheritance analysis
        - Variable dependencies
        - Function modifiers
        """
        try:
            # Create temporary file with source code
            with tempfile.NamedTemporaryFile(suffix='.sol', mode='w') as tmp:
                tmp.write(source_code)
                tmp.flush()
                
                # Initialize Slither
                slither = Slither(tmp.name)
                
                # Get results
                results = {
                    'vulnerabilities': slither.detectors,
                    'inheritance': slither.inheritance,
                    'variables': slither.variables,
                    'functions': slither.functions,
                    'modifiers': slither.modifiers
                }
                
                return results
                
        except Exception as e:
            logger.error(f"Slither analysis error: {str(e)}")
            return {}

    async def _run_mythril_analysis(self, contract_address: str) -> Dict:
        """Run Mythril security analyzer
        
        Mythril is great for:
        - Symbolic execution
        - Smart contract security analysis
        - Finding complex vulnerabilities
        """
        try:
            # Get contract bytecode
            bytecode = await self.web3.eth.get_code(contract_address)
            
            # Initialize Mythril
            disassembler = MythrilDisassembler()
            disassembler.load_from_bytecode(bytecode)
            
            # Run analysis
            analysis = self.mythril.analyze()
            
            return {
                'issues': analysis.issues,
                'execution_paths': analysis.execution_paths,
                'coverage': analysis.coverage
            }
            
        except Exception as e:
            logger.error(f"Mythril analysis error: {str(e)}")
            return {}

    async def _run_manticore_analysis(self, contract_address: str) -> Dict:
        """Run Manticore symbolic execution engine
        
        Manticore excels at:
        - Path exploration
        - Finding edge cases
        - Generating test cases
        """
        try:
            # Initialize Manticore with contract
            self.manticore.register_contract(contract_address)
            
            # Run symbolic execution
            self.manticore.run()
            
            # Get results
            results = {
                'coverage': self.manticore.coverage,
                'findings': self.manticore.findings,
                'test_cases': self.manticore.test_cases
            }
            
            return results
            
        except Exception as e:
            logger.error(f"Manticore analysis error: {str(e)}")
            return {}

    async def _run_echidna_tests(self, source_code: str) -> Dict:
        """Run Echidna property-based testing
        
        Echidna is powerful for:
        - Fuzzing
        - Property testing
        - Finding edge cases
        """
        try:
            # Initialize Echidna
            echidna = Echidna()
            
            # Add contract code
            echidna.add_source(source_code)
            
            # Run tests
            results = echidna.run()
            
            return {
                'property_violations': results.violations,
                'coverage': results.coverage,
                'test_results': results.results
            }
            
        except Exception as e:
            logger.error(f"Echidna testing error: {str(e)}")
            return {}

    async def _decompile_contract(self, contract_address: str) -> Optional[str]:
        """Decompile contract using available decompilers
        
        Attempts:
        1. Panoramix (if available)
        2. Etherscan API (if configured)
        3. Internal simple decompiler
        """
        try:
            # Try Panoramix first
            try:
                from panoramix.decompiler import decompile_bytecode
                bytecode = await self.web3.eth.get_code(contract_address)
                return decompile_bytecode(bytecode)
            except ImportError:
                pass

            # Try Etherscan API
            if hasattr(self, 'etherscan_api_key'):
                # Implementation for Etherscan API call
                pass

            # Fallback to simple decompiler
            return await self._simple_decompile(contract_address)

        except Exception as e:
            logger.error(f"Decompilation error: {str(e)}")
            return None

class VulnerabilityScanner:
    def __init__(self):
        self.state_manager = StateManager()
        self.llm = LLMInterface()
        self.scanned_contracts: Set[str] = set()
        self.vulnerability_patterns = self._load_vulnerability_patterns()
        self.detection_tools = {
            'static': ['slither', 'mythril', 'securify'],
            'dynamic': ['echidna', 'manticore', 'foundry'],
            'symbolic': ['mythril', 'manticore'],
            'fuzzing': ['echidna', 'foundry']
        }
        
    async def scan_contract(self,
                          contract_address: str,
                          chain_id: int,
                          options: Optional[Dict] = None) -> List[Vulnerability]:
        """Comprehensive contract vulnerability scan"""
        try:
            vulnerabilities = []
            
            # Get contract code and ABI
            code = await self.state_manager.get_contract_code(contract_address)
            abi = await self.state_manager.get_contract_abi(contract_address)
            
            # Static Analysis
            static_vulns = await self._run_static_analysis(code, abi)
            vulnerabilities.extend(static_vulns)
            
            # Dynamic Analysis
            dynamic_vulns = await self._run_dynamic_analysis(
                contract_address,
                chain_id,
                code
            )
            vulnerabilities.extend(dynamic_vulns)
            
            # Symbolic Execution
            symbolic_vulns = await self._run_symbolic_analysis(code)
            vulnerabilities.extend(symbolic_vulns)
            
            # Fuzzing
            fuzzing_vulns = await self._run_fuzzing(contract_address, chain_id)
            vulnerabilities.extend(fuzzing_vulns)
            
            # AI-Enhanced Pattern Detection
            ai_vulns = await self._run_ai_analysis(
                code,
                abi,
                contract_address,
                chain_id
            )
            vulnerabilities.extend(ai_vulns)
            
            # Deduplicate and merge related vulnerabilities
            final_vulns = self._deduplicate_vulnerabilities(vulnerabilities)
            
            # Update vulnerability database
            await self._update_vulnerability_db(final_vulns)
            
            return final_vulns
            
        except Exception as e:
            logger.error(f"Error scanning contract: {str(e)}")
            return []

    async def _run_static_analysis(self, code: str, abi: Dict) -> List[Vulnerability]:
        """Run static analysis tools"""
        vulnerabilities = []
        
        # Slither Analysis
        slither_vulns = await self._run_slither(code)
        vulnerabilities.extend(slither_vulns)
        
        # Mythril Static Analysis
        mythril_vulns = await self._run_mythril_static(code)
        vulnerabilities.extend(mythril_vulns)
        
        # Securify Analysis
        securify_vulns = await self._run_securify(code)
        vulnerabilities.extend(securify_vulns)
        
        return vulnerabilities

    async def _run_dynamic_analysis(self,
                                  contract_address: str,
                                  chain_id: int,
                                  code: str) -> List[Vulnerability]:
        """Run dynamic analysis tools"""
        vulnerabilities = []
        
        # Fork chain state
        fork = await self.state_manager.create_fork(chain_id)
        
        # Echidna Dynamic Testing
        echidna_vulns = await self._run_echidna(
            contract_address,
            code,
            fork
        )
        vulnerabilities.extend(echidna_vulns)
        
        # Manticore Dynamic Analysis
        manticore_vulns = await self._run_manticore(
            contract_address,
            code,
            fork
        )
        vulnerabilities.extend(manticore_vulns)
        
        # Foundry Testing
        foundry_vulns = await self._run_foundry_tests(
            contract_address,
            code,
            fork
        )
        vulnerabilities.extend(foundry_vulns)
        
        # Clean up fork
        await self.state_manager.delete_fork(fork)
        
        return vulnerabilities

    async def _run_symbolic_analysis(self, code: str) -> List[Vulnerability]:
        """Run symbolic execution analysis"""
        vulnerabilities = []
        
        # Mythril Symbolic Analysis
        mythril_vulns = await self._run_mythril_symbolic(code)
        vulnerabilities.extend(mythril_vulns)
        
        # Manticore Symbolic Analysis
        manticore_vulns = await self._run_manticore_symbolic(code)
        vulnerabilities.extend(manticore_vulns)
        
        return vulnerabilities

    async def _run_fuzzing(self,
                          contract_address: str,
                          chain_id: int) -> List[Vulnerability]:
        """Run fuzzing tests"""
        vulnerabilities = []
        
        # Echidna Fuzzing
        echidna_vulns = await self._run_echidna_fuzzing(
            contract_address,
            chain_id
        )
        vulnerabilities.extend(echidna_vulns)
        
        # Foundry Fuzzing
        foundry_vulns = await self._run_foundry_fuzzing(
            contract_address,
            chain_id
        )
        vulnerabilities.extend(foundry_vulns)
        
        return vulnerabilities

    async def _run_ai_analysis(self,
                              code: str,
                              abi: Dict,
                              contract_address: str,
                              chain_id: int) -> List[Vulnerability]:
        """Run AI-enhanced vulnerability detection"""
        try:
            # Get AI analysis of code
            ai_analysis = await self.llm.analyze_contract(
                code,
                abi,
                chain_id
            )
            
            vulnerabilities = []
            
            # Convert AI findings to vulnerabilities
            for finding in ai_analysis.get('findings', []):
                vuln = Vulnerability(
                    id=f"AI-{finding['type']}-{len(vulnerabilities)}",
                    name=finding['name'],
                    type=finding['type'],
                    severity=finding['severity'],
                    confidence=finding['confidence'],
                    description=finding['description'],
                    impact=finding['impact'],
                    attack_vectors=finding['attack_vectors'],
                    affected_functions=finding['affected_functions'],
                    proof_of_concept=finding.get('poc'),
                    exploit_script=finding.get('exploit'),
                    mitigation=finding['mitigation'],
                    references=finding['references'],
                    dependencies=finding.get('dependencies', []),
                    chain_id=chain_id,
                    detection_tool='ai'
                )
                vulnerabilities.append(vuln)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Error in AI analysis: {str(e)}")
            return []

    def _load_vulnerability_patterns(self) -> Dict:
        """Load vulnerability patterns for each chain"""
        patterns = {}
        for chain_id in config.get_all_chain_ids():
            chain_config = config.get_chain_config(chain_id)
            patterns[chain_id] = {
                'reentrancy': self._get_reentrancy_patterns(chain_config),
                'flash_loan': self._get_flash_loan_patterns(chain_config),
                'price_manipulation': self._get_price_manipulation_patterns(chain_config),
                'governance': self._get_governance_patterns(chain_config),
                'bridge': self._get_bridge_patterns(chain_config),
                'oracle': self._get_oracle_patterns(chain_config)
            }
        return patterns

    async def _run_slither(self, code: str) -> List[Vulnerability]:
        """Run Slither analysis with chain-specific detectors"""
        try:
            from slither.slither import Slither
            from slither.detectors.all_detectors import all_detectors

            # Create temporary file
            with tempfile.NamedTemporaryFile(suffix='.sol', mode='w') as temp_file:
                temp_file.write(code)
                temp_file.flush()

                # Initialize Slither
                slither = Slither(temp_file.name)
                
                vulnerabilities = []
                
                # Run all detectors
                for detector in all_detectors:
                    results = slither.run_detector(detector)
                    for result in results:
                        vuln = self._convert_slither_result(result)
                        if vuln:
                            vulnerabilities.append(vuln)

                return vulnerabilities

        except Exception as e:
            logger.error(f"Error in Slither analysis: {str(e)}")
            return []

    async def _run_mythril_static(self, code: str) -> List[Vulnerability]:
        """Run Mythril static analysis"""
        try:
            from mythril.mythril import MythrilDisassembler
            from mythril.analysis.security import fire_lasers
            
            # Initialize Mythril
            disassembler = MythrilDisassembler()
            address, _ = disassembler.load_from_solidity(code)
            
            # Run analysis
            report = fire_lasers(address)
            
            return self._convert_mythril_results(report.issues)
            
        except Exception as e:
            logger.error(f"Error in Mythril static analysis: {str(e)}")
            return []

    def _deduplicate_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Vulnerability]:
        """Deduplicate and merge related vulnerabilities"""
        try:
            # Group by type and location
            grouped = {}
            for vuln in vulnerabilities:
                key = f"{vuln.type}_{','.join(sorted(vuln.affected_functions))}"
                if key not in grouped:
                    grouped[key] = []
                grouped[key].append(vuln)
            
            # Merge related vulnerabilities
            final_vulns = []
            for vulns in grouped.values():
                if len(vulns) == 1:
                    final_vulns.append(vulns[0])
                else:
                    merged = self._merge_vulnerabilities(vulns)
                    final_vulns.append(merged)
            
            return final_vulns
            
        except Exception as e:
            logger.error(f"Error deduplicating vulnerabilities: {str(e)}")
            return vulnerabilities

    def _merge_vulnerabilities(self, vulns: List[Vulnerability]) -> Vulnerability:
        """Merge related vulnerabilities into one"""
        try:
            # Take highest severity and confidence
            severity = max(v.severity for v in vulns)
            confidence = max(v.confidence for v in vulns)
            
            # Combine descriptions and impacts
            description = "\n".join(set(v.description for v in vulns))
            impact = self._merge_dicts([v.impact for v in vulns])
            
            # Combine attack vectors
            attack_vectors = []
            for v in vulns:
                attack_vectors.extend(v.attack_vectors)
            
            # Use most detailed PoC and exploit
            poc = next((v.proof_of_concept for v in vulns if v.proof_of_concept), None)
            exploit = next((v.exploit_script for v in vulns if v.exploit_script), None)
            
            return Vulnerability(
                id=f"MERGED-{vulns[0].type}-{len(vulns)}",
                name=vulns[0].name,
                type=vulns[0].type,
                severity=severity,
                confidence=confidence,
                description=description,
                impact=impact,
                attack_vectors=attack_vectors,
                affected_functions=list(set().union(*(v.affected_functions for v in vulns))),
                proof_of_concept=poc,
                exploit_script=exploit,
                mitigation="\n".join(set(v.mitigation for v in vulns)),
                references=list(set().union(*(v.references for v in vulns))),
                dependencies=list(set().union(*(v.dependencies for v in vulns))),
                chain_id=vulns[0].chain_id,
                detection_tool=f"multiple_{len(set(v.detection_tool for v in vulns))}"
            )
            
        except Exception as e:
            logger.error(f"Error merging vulnerabilities: {str(e)}")
            return vulns[0]

    def _get_reentrancy_patterns(self, chain_config: ChainConfig) -> Dict:
        """Get chain-specific reentrancy patterns"""
        return {
            'standard': {
                'functions': ['transfer', 'send', 'call'],
                'state_variables': ['balances', 'totalSupply', 'allowances'],
                'external_calls': True,
                'state_changes_after_call': True
            },
            'cross_function': {
                'shared_state': True,
                'multiple_functions': True,
                'state_dependency': True
            },
            'cross_contract': {
                'external_contracts': chain_config.lending_protocols.values(),
                'dex_contracts': chain_config.dex_addresses.values(),
                'flash_loan_contracts': chain_config.flash_loan_providers.values()
            }
        }

    def _get_flash_loan_patterns(self, chain_config: ChainConfig) -> Dict:
        """Get chain-specific flash loan patterns"""
        return {
            'providers': {
                provider: {
                    'address': addr,
                    'functions': self._get_flash_loan_functions(provider),
                    'tokens': self._get_supported_tokens(addr)
                }
                for provider, addr in chain_config.flash_loan_providers.items()
            },
            'attack_vectors': {
                'price_manipulation': {
                    'dexes': chain_config.dex_addresses,
                    'amm_pools': chain_config.amm_pools,
                    'oracles': chain_config.oracle_addresses
                },
                'governance': {
                    'voting_tokens': self._get_voting_tokens(chain_config),
                    'governance_contracts': self._get_governance_contracts(chain_config)
                },
                'liquidation': {
                    'lending_pools': chain_config.lending_pools,
                    'collateral_tokens': self._get_collateral_tokens(chain_config)
                }
            }
        }

    def _get_price_manipulation_patterns(self, chain_config: ChainConfig) -> Dict:
        """Get chain-specific price manipulation patterns"""
        return {
            'dex_patterns': {
                'sandwich_attack': {
                    'frontrun_patterns': self._get_frontrun_patterns(),
                    'backrun_patterns': self._get_backrun_patterns(),
                    'target_functions': ['swapExactTokensForTokens', 'swapTokensForExactTokens']
                },
                'liquidity_manipulation': {
                    'pool_contracts': chain_config.amm_pools,
                    'vulnerable_functions': ['addLiquidity', 'removeLiquidity', 'sync']
                }
            },
            'oracle_patterns': {
                'manipulation_vectors': {
                    'twap': self._get_twap_manipulation_patterns(),
                    'spot': self._get_spot_manipulation_patterns(),
                    'chainlink': self._get_chainlink_manipulation_patterns()
                },
                'oracle_contracts': chain_config.oracle_addresses
            },
            'arbitrage_patterns': {
                'cross_dex': self._get_cross_dex_patterns(chain_config),
                'cross_chain': self._get_cross_chain_patterns(chain_config)
            }
        }

    def _get_bridge_patterns(self, chain_config: ChainConfig) -> Dict:
        """Get chain-specific bridge vulnerability patterns"""
        return {
            'bridge_contracts': {
                bridge: {
                    'address': details['gateway'],
                    'router': details['router'],
                    'patterns': self._get_bridge_specific_patterns(bridge)
                }
                for bridge, details in chain_config.cross_chain_bridges.items()
            },
            'validation_patterns': {
                'message_verification': self._get_message_verification_patterns(),
                'signature_verification': self._get_signature_verification_patterns(),
                'relay_validation': self._get_relay_validation_patterns()
            },
            'asset_handling': {
                'lock_unlock': self._get_lock_unlock_patterns(),
                'mint_burn': self._get_mint_burn_patterns(),
                'wrapped_tokens': self._get_wrapped_token_patterns()
            }
        }

    async def _run_manticore(self, contract_address: str, code: str, fork: str) -> List[Vulnerability]:
        """Run Manticore dynamic analysis"""
        try:
            from manticore.ethereum import ManticoreEVM
            from manticore.core.smtlib import Operators

            # Initialize Manticore with fork state
            m = ManticoreEVM()
            
            # Add contract to Manticore
            source_code = m.make_symbolic_buffer(len(code))
            contract = m.solidity_create_contract(source_code)
            
            # Define security properties
            await self._define_security_properties(m, contract)
            
            # Run analysis
            m.run(procs=10)
            
            # Process results
            vulnerabilities = []
            for state in m.terminated_states:
                if state.is_error:
                    vuln = self._process_manticore_state(state)
                    if vuln:
                        vulnerabilities.append(vuln)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Error in Manticore analysis: {str(e)}")
            return []

    async def _run_echidna_fuzzing(self, contract_address: str, chain_id: int) -> List[Vulnerability]:
        """Run Echidna fuzzing with chain-specific configurations"""
        try:
            # Get chain-specific configuration
            chain_config = config.get_chain_config(chain_id)
            
            # Create Echidna configuration
            echidna_config = self._create_echidna_config(chain_config)
            
            # Initialize Echidna
            corpus = self._generate_fuzzing_corpus(contract_address, chain_config)
            
            # Run fuzzing campaign
            results = await self._run_fuzzing_campaign(
                contract_address,
                echidna_config,
                corpus
            )
            
            return self._process_echidna_results(results)
            
        except Exception as e:
            logger.error(f"Error in Echidna fuzzing: {str(e)}")
            return []

    def _get_frontrun_patterns(self) -> Dict:
        """Get patterns for detecting frontrunning opportunities"""
        return {
            'mempool_monitoring': {
                'target_functions': [
                    'swap', 'trade', 'deposit', 'withdraw',
                    'mint', 'burn', 'stake', 'unstake'
                ],
                'value_indicators': [
                    'amount', 'minOutput', 'maxInput',
                    'deadline', 'slippage'
                ]
            },
            'transaction_ordering': {
                'gas_price_manipulation': True,
                'bundle_transactions': True,
                'flashbots_integration': True
            }
        }

    def _get_backrun_patterns(self) -> Dict:
        """Get patterns for detecting backrunning opportunities"""
        return {
            'state_changes': {
                'price_impact': True,
                'liquidity_changes': True,
                'reserve_updates': True
            },
            'profitable_states': {
                'arbitrage_opportunity': True,
                'liquidation_threshold': True,
                'rebalancing_needed': True
            }
        }

    def _get_twap_manipulation_patterns(self) -> Dict:
        """Get TWAP oracle manipulation patterns"""
        return {
            'time_weighted': {
                'observation_period': [1, 10, 30, 60],  # minutes
                'price_impact_threshold': 0.02,  # 2%
                'volume_anomaly_threshold': 3.0  # 3x normal
            },
            'manipulation_vectors': {
                'flash_loan_attack': True,
                'sandwich_attack': True,
                'multi_pool_manipulation': True
            }
        }

    def _get_spot_manipulation_patterns(self) -> Dict:
        """Get spot price manipulation patterns"""
        return {
            'single_block': {
                'max_price_impact': 0.05,  # 5%
                'suspicious_volume': True,
                'flash_loan_correlation': True
            },
            'multi_block': {
                'price_deviation': 0.10,  # 10%
                'volume_spike': True,
                'wash_trading': True
            }
        }

    def _get_chainlink_manipulation_patterns(self) -> Dict:
        """Get Chainlink oracle manipulation patterns"""
        return {
            'feed_manipulation': {
                'deviation_threshold': 0.03,  # 3%
                'heartbeat_check': True,
                'stale_price_check': True
            },
            'aggregator_attack': {
                'minority_response': True,
                'delayed_response': True,
                'malicious_nodes': True
            }
        }

    async def _define_security_properties(self, m: 'ManticoreEVM', contract: 'Contract'):
        """Define security properties for symbolic execution"""
        try:
            # Balance consistency
            m.add_assertion(
                lambda state: state.platform.get_balance(contract.address) >= 0
            )

            # Access control
            m.add_assertion(
                lambda state: self._verify_access_control(state, contract)
            )

            # Arithmetic safety
            m.add_assertion(
                lambda state: self._verify_arithmetic_safety(state)
            )

            # State consistency
            m.add_assertion(
                lambda state: self._verify_state_consistency(state, contract)
            )

            # Reentrancy protection
            m.add_assertion(
                lambda state: self._verify_reentrancy_guard(state, contract)
            )

        except Exception as e:
            logger.error(f"Error defining security properties: {str(e)}")

    def _create_echidna_config(self, chain_config: ChainConfig) -> Dict:
        """Create chain-specific Echidna configuration"""
        return {
            'testMode': 'assertion',
            'testLimit': 50000,
            'seqLen': 100,
            'shrinkLimit': 5000,
            'coverage': True,
            'corpusDir': './corpus',
            'workers': 10,
            'sender': [
                chain_config.flash_loan_providers.values(),
                chain_config.dex_addresses.values(),
                chain_config.lending_protocols.values()
            ],
            'balanceContract': 100000000000000000000,  # 100 ETH
            'balanceAddr': 100000000000000000000,
            'propertyTesting': {
                'testLimit': 10000,
                'stopOnFail': False,
                'estimateGas': True
            }
        }

    async def _generate_exploit_script(self, 
                                     vulnerability: Vulnerability,
                                     chain_id: int) -> Optional[str]:
        """Generate exploit script for vulnerability"""
        try:
            # Get chain configuration
            chain_config = config.get_chain_config(chain_id)
            
            # Generate base exploit template
            template = await self._generate_exploit_template(vulnerability)
            
            # Add flash loan integration if applicable
            if self._can_use_flash_loans(vulnerability, chain_config):
                template = await self._add_flash_loan_logic(
                    template,
                    vulnerability,
                    chain_config
                )
            
            # Add MEV optimization if profitable
            if self._is_mev_opportunity(vulnerability):
                template = await self._add_mev_optimization(
                    template,
                    chain_config
                )
            
            # Add cross-contract interactions
            if vulnerability.dependencies:
                template = await self._add_dependency_interactions(
                    template,
                    vulnerability.dependencies,
                    chain_config
                )
            
            # Optimize gas usage
            optimized = await self._optimize_exploit_gas(template, chain_config)
            
            # Add validation checks
            final_script = await self._add_validation_checks(
                optimized,
                vulnerability
            )
            
            return final_script
            
        except Exception as e:
            logger.error(f"Error generating exploit script: {str(e)}")
            return None

    async def _calculate_exploit_profitability(self,
                                            vulnerability: Vulnerability,
                                            chain_id: int) -> Dict:
        """Calculate potential profit from exploit"""
        try:
            profit_analysis = {
                'estimated_profit': 0,
                'required_capital': 0,
                'gas_costs': 0,
                'flash_loan_fees': 0,
                'success_probability': 0,
                'risk_factors': [],
                'optimal_path': [],
                'dependencies': []
            }
            
            # Get chain state
            state = await self.state_manager.get_state(chain_id)
            
            # Calculate base profit
            base_profit = await self._calculate_base_profit(
                vulnerability,
                state
            )
            
            # Calculate required capital
            required_capital = await self._calculate_required_capital(
                vulnerability,
                state
            )
            
            # Estimate gas costs
            gas_costs = await self._estimate_gas_costs(
                vulnerability,
                chain_id
            )
            
            # Calculate flash loan fees if applicable
            flash_loan_fees = await self._calculate_flash_loan_fees(
                vulnerability,
                required_capital,
                chain_id
            )
            
            # Calculate success probability
            success_prob = self._calculate_success_probability(
                vulnerability,
                state
            )
            
            # Find optimal attack path
            optimal_path = await self._find_optimal_attack_path(
                vulnerability,
                base_profit,
                gas_costs,
                chain_id
            )
            
            # Update profit analysis
            profit_analysis.update({
                'estimated_profit': base_profit - gas_costs - flash_loan_fees,
                'required_capital': required_capital,
                'gas_costs': gas_costs,
                'flash_loan_fees': flash_loan_fees,
                'success_probability': success_prob,
                'optimal_path': optimal_path
            })
            
            return profit_analysis
            
        except Exception as e:
            logger.error(f"Error calculating profitability: {str(e)}")
            return {'estimated_profit': 0}

    async def _find_optimal_attack_path(self,
                                      vulnerability: Vulnerability,
                                      base_profit: float,
                                      gas_costs: float,
                                      chain_id: int) -> List[Dict]:
        """Find optimal path to maximize exploit profit"""
        try:
            paths = []
            chain_config = config.get_chain_config(chain_id)
            
            # Check direct exploit
            direct_path = {
                'steps': [self._create_exploit_step(vulnerability)],
                'profit': base_profit - gas_costs,
                'complexity': 1
            }
            paths.append(direct_path)
            
            # Check flash loan enhanced path
            if self._can_use_flash_loans(vulnerability, chain_config):
                flash_path = await self._create_flash_loan_path(
                    vulnerability,
                    base_profit,
                    chain_config
                )
                if flash_path['profit'] > direct_path['profit']:
                    paths.append(flash_path)
            
            # Check MEV enhanced path
            mev_path = await self._create_mev_path(
                vulnerability,
                base_profit,
                chain_config
            )
            if mev_path and mev_path['profit'] > direct_path['profit']:
                paths.append(mev_path)
            
            # Check cross-contract path
            if vulnerability.dependencies:
                cross_path = await self._create_cross_contract_path(
                    vulnerability,
                    base_profit,
                    chain_config
                )
                if cross_path['profit'] > direct_path['profit']:
                    paths.append(cross_path)
            
            # Return path with highest profit
            return max(paths, key=lambda x: x['profit'])['steps']
            
        except Exception as e:
            logger.error(f"Error finding optimal attack path: {str(e)}")
            return [] 