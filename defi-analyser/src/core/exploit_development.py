from typing import List, Dict, Any, Optional
from dataclasses import dataclass
import asyncio
from web3 import Web3
from eth_abi import decode_abi
import torch
import numpy as np
from scipy.optimize import linear_sum_assignment
from transformers import AutoModelForCausalLM, AutoTokenizer
import pandas as pd
from sklearn.ensemble import IsolationForest, RandomForestRegressor
import xgboost as xgb
from torch.nn import LSTM, Linear, MSELoss

class MarketRiskAnalyzer:
    def __init__(self):
        self.lstm_model = self._build_lstm_model()
        self.xgb_model = xgb.XGBRegressor(
            max_depth=12,
            learning_rate=0.01,
            n_estimators=1000,
            tree_method='gpu_hist'
        )
        self.isolation_forest = IsolationForest(
            n_estimators=1000,
            contamination=0.01,
            random_state=42
        )

    def _build_lstm_model(self):
        class LSTMPredictor(torch.nn.Module):
            def __init__(self, input_dim=64, hidden_dim=128, num_layers=3):
                super().__init__()
                self.lstm = LSTM(
                    input_dim,
                    hidden_dim,
                    num_layers,
                    batch_first=True,
                    dropout=0.2
                )
                self.fc = Linear(hidden_dim, 1)

            def forward(self, x):
                lstm_out, _ = self.lstm(x)
                return self.fc(lstm_out[:, -1, :])

        return LSTMPredictor()

    async def analyze_market_risk(self, 
                                strategy: ExploitStrategy,
                                market_data: pd.DataFrame) -> Dict[str, float]:
        """
        Advanced market risk analysis using ML ensemble
        """
        # Prepare market features
        features = self._extract_market_features(market_data)
        
        # LSTM prediction
        lstm_pred = self._get_lstm_prediction(features)
        
        # XGBoost prediction
        xgb_pred = self._get_xgb_prediction(features)
        
        # Anomaly detection
        anomaly_score = self._detect_anomalies(features)
        
        # Combine predictions with weights
        risk_score = self._combine_risk_scores({
            'lstm': lstm_pred,
            'xgb': xgb_pred,
            'anomaly': anomaly_score
        })
        
        return {
            'risk_score': risk_score,
            'confidence': self._calculate_confidence(
                lstm_pred, xgb_pred, anomaly_score
            ),
            'market_impact': self._estimate_market_impact(
                strategy, features
            ),
            'volatility_risk': self._analyze_volatility(features),
            'liquidity_risk': self._analyze_liquidity(features)
        }

class OperationalRiskAnalyzer:
    def __init__(self):
        self.rf_model = RandomForestRegressor(
            n_estimators=1000,
            max_depth=15,
            n_jobs=-1
        )
        
    async def analyze_operational_risk(self,
                                     strategy: ExploitStrategy,
                                     execution_history: pd.DataFrame) -> Dict[str, float]:
        """
        Advanced operational risk analysis
        """
        # Extract operational features
        features = self._extract_operational_features(
            strategy,
            execution_history
        )
        
        # Analyze execution complexity
        complexity_score = self._analyze_complexity(features)
        
        # Analyze technical dependencies
        dependency_risk = self._analyze_dependencies(strategy)
        
        # Analyze gas optimization
        gas_risk = self._analyze_gas_risk(strategy)
        
        # Analyze timing constraints
        timing_risk = self._analyze_timing_risk(strategy)
        
        return {
            'complexity_risk': complexity_score,
            'dependency_risk': dependency_risk,
            'gas_risk': gas_risk,
            'timing_risk': timing_risk,
            'total_risk': self._combine_operational_risks([
                complexity_score,
                dependency_risk,
                gas_risk,
                timing_risk
            ])
        }

class RegulatoryRiskAnalyzer:
    def __init__(self):
        self.chain_regulations = self._load_chain_regulations()
        self.compliance_model = self._build_compliance_model()
        
    async def analyze_regulatory_risk(self,
                                    strategy: ExploitStrategy,
                                    chain_id: int) -> Dict[str, float]:
        """
        Advanced regulatory risk analysis
        """
        # Get chain-specific regulations
        chain_regs = self.chain_regulations[chain_id]
        
        # Analyze compliance
        compliance_score = self._analyze_compliance(
            strategy,
            chain_regs
        )
        
        # Analyze jurisdictional risk
        jurisdiction_risk = self._analyze_jurisdiction(
            chain_id,
            strategy
        )
        
        # Analyze regulatory trends
        trend_risk = self._analyze_regulatory_trends(
            chain_id,
            strategy
        )
        
        return {
            'compliance_score': compliance_score,
            'jurisdiction_risk': jurisdiction_risk,
            'trend_risk': trend_risk,
            'total_risk': self._combine_regulatory_risks([
                compliance_score,
                jurisdiction_risk,
                trend_risk
            ])
        } 